//! This example shows how to create a custom render pass that runs after the main pass
//! and reads the texture generated by the main pass.
//!
//! The example shader is a very simple implementation of chromatic aberration.
//!
//! This is a fairly low level example and assumes some familiarity with rendering concepts and wgpu.

mod camera_controller;
mod cloud;
mod volume;

use bevy::{
    asset::LoadState,
    core_pipeline::{
        clear_color::ClearColorConfig,
        core_3d::{self, Transparent3d},
        fullscreen_vertex_shader::fullscreen_shader_vertex_state,
        Skybox,
    },
    ecs::{
        query::QueryItem,
        system::{
            lifetimeless::{Read, SRes},
            SystemParamItem,
        },
    },
    pbr::{
        MeshPipeline, MeshPipelineKey, RenderMeshInstances, SetMeshBindGroup, SetMeshViewBindGroup,
    },
    prelude::*,
    render::{
        extract_component::{
            ComponentUniforms, ExtractComponent, ExtractComponentPlugin, UniformComponentPlugin,
        },
        mesh::{GpuBufferInfo, MeshVertexBufferLayout},
        render_asset::RenderAssets,
        render_graph::{
            NodeRunError, RenderGraphApp, RenderGraphContext, ViewNode, ViewNodeRunner,
        },
        render_phase::{
            AddRenderCommand, DrawFunctions, PhaseItem, RenderCommand, RenderCommandResult,
            RenderPhase, SetItemPipeline, TrackedRenderPass,
        },
        render_resource::{
            BindGroupEntries, BindGroupLayout, BindGroupLayoutDescriptor, BindGroupLayoutEntry,
            BindingType, Buffer, BufferInitDescriptor, BufferUsages, CachedRenderPipelineId,
            ColorTargetState, ColorWrites, FragmentState, MultisampleState, Operations,
            PipelineCache, PrimitiveState, RenderPassColorAttachment, RenderPassDescriptor,
            RenderPipelineDescriptor, Sampler, SamplerBindingType, SamplerDescriptor, ShaderStages,
            ShaderType, SpecializedMeshPipeline, SpecializedMeshPipelineError,
            SpecializedMeshPipelines, TextureFormat, TextureSampleType, TextureViewDescriptor,
            TextureViewDimension, VertexAttribute, VertexBufferLayout, VertexFormat,
            VertexStepMode,
        },
        renderer::{RenderContext, RenderDevice},
        texture::BevyDefault,
        view::{ExtractedView, NoFrustumCulling, ViewTarget},
        Render, RenderApp, RenderSet,
    },
    sprite::MaterialMesh2dBundle,
};

use bytemuck::{Pod, Zeroable};

use camera_controller::{PanOrbitCamera, PanOrbitCameraPlugin};
use vdb_rs::VdbReader;

use std::{error::Error, fs::File, io::BufReader};

use cloud::{CloudRenderPlugin, CloudSettings};

fn main() {
    App::new()
        .add_plugins((DefaultPlugins, PanOrbitCameraPlugin, CloudRenderPlugin))
        .init_asset_loader::<volume::loader::VolumeLoader>()
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_light, skybox_loaded))
        .run();
}

#[derive(Component)]
struct MainCamera;

fn rotate_light(time: Res<Time>, mut query: Query<&mut Transform, With<DirectionalLight>>) {
    for mut transform in &mut query {
        transform.rotate(Quat::from_rotation_y(time.delta_seconds()));
    }
}

fn setup(
    mut commands: Commands,
    images: Res<Assets<Image>>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    asset_server: Res<AssetServer>,
) {
    let skybox_handle = asset_server.load("textures/StandardCubeMap.png");
    commands.insert_resource(SkyboxTexture {
        image: skybox_handle.clone(),
    });

    commands.spawn(DirectionalLightBundle {
        transform: Transform::from_xyz(0.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(0.0, 2.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        MainCamera,
        PanOrbitCamera::default(),
        // Skybox(skybox_handle),
    ));

    commands.spawn((PbrBundle {
        transform: Transform::from_xyz(0.0, -1.0, 0.0),
        mesh: meshes.add(Mesh::from(shape::Plane {
            size: 5.0,
            subdivisions: 100,
        })),
        material: materials.add(Color::rgb(0.3, 0.5, 0.3).into()),
        ..Default::default()
    },));
}

#[derive(Resource)]
struct SkyboxTexture {
    image: Handle<Image>,
}

fn skybox_loaded(
    asset_server: Res<AssetServer>,
    mut images: ResMut<Assets<Image>>,
    mut skybox_texture: ResMut<SkyboxTexture>,
    mut skyboxes: Query<&mut Skybox>,
) {
    if asset_server.load_state(&skybox_texture.image) == LoadState::Loaded {
        let image = images.get_mut(&skybox_texture.image).unwrap();
        if image.texture_descriptor.array_layer_count() == 1 {
            image.reinterpret_stacked_2d_as_array(image.height() / image.width());
            image.texture_view_descriptor = Some(TextureViewDescriptor {
                dimension: Some(TextureViewDimension::Cube),
                ..default()
            });
        }
    }
}
