//! This example shows how to create a custom render pass that runs after the main pass
//! and reads the texture generated by the main pass.
//!
//! The example shader is a very simple implementation of chromatic aberration.
//!
//! This is a fairly low level example and assumes some familiarity with rendering concepts and wgpu.

mod camera_controller;
mod cloud;
mod volume;

use bevy::{
    asset::LoadState,
    core_pipeline::Skybox,
    prelude::*,
    render::{
        render_graph::ViewNode,
        render_resource::{TextureViewDescriptor, TextureViewDimension},
    },
};

use camera_controller::{PanOrbitCamera, PanOrbitCameraPlugin};

use cloud::CloudRenderPlugin;

fn main() {
    App::new()
        .add_plugins((DefaultPlugins, PanOrbitCameraPlugin, CloudRenderPlugin))
        .init_asset_loader::<volume::loader::VolumeLoader>()
        .add_systems(Startup, setup)
        .add_systems(Update, (rotate_light, skybox_loaded))
        .run();
}

#[derive(Component)]
struct MainCamera;

fn rotate_light(time: Res<Time>, mut query: Query<&mut Transform, With<DirectionalLight>>) {
    for mut transform in &mut query {
        transform.rotate(Quat::from_rotation_y(time.delta_seconds()));
    }
}

fn setup(
    mut commands: Commands,
    _images: Res<Assets<Image>>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    asset_server: Res<AssetServer>,
) {
    let skybox_handle = asset_server.load("textures/StandardCubeMap.png");
    commands.insert_resource(SkyboxTexture {
        image: skybox_handle.clone(),
    });

    commands.spawn(DirectionalLightBundle {
        transform: Transform::from_xyz(0.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(0.0, 2.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        MainCamera,
        PanOrbitCamera::default(),
        // Skybox(skybox_handle),
    ));

    commands.spawn((PbrBundle {
        transform: Transform::from_xyz(0.0, -1.0, 0.0),
        mesh: meshes.add(Mesh::from(shape::Plane {
            size: 5.0,
            subdivisions: 100,
        })),
        material: materials.add(Color::rgb(0.3, 0.5, 0.3).into()),
        ..Default::default()
    },));
}

#[derive(Resource)]
struct SkyboxTexture {
    image: Handle<Image>,
}

fn skybox_loaded(
    asset_server: Res<AssetServer>,
    mut images: ResMut<Assets<Image>>,
    skybox_texture: ResMut<SkyboxTexture>,
    _skyboxes: Query<&mut Skybox>,
) {
    if asset_server.load_state(&skybox_texture.image) == LoadState::Loaded {
        let image = images.get_mut(&skybox_texture.image).unwrap();
        if image.texture_descriptor.array_layer_count() == 1 {
            image.reinterpret_stacked_2d_as_array(image.height() / image.width());
            image.texture_view_descriptor = Some(TextureViewDescriptor {
                dimension: Some(TextureViewDimension::Cube),
                ..default()
            });
        }
    }
}
